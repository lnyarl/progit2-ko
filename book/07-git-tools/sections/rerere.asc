[[_rerere]]
=== Rerere

///////////////////
The `git rerere` functionality is a bit of a hidden feature.  The name stands for ``reuse recorded resolution'' and as the name implies, it allows you to ask Git to remember how you've resolved a hunk conflict so that the next time it sees the same conflict, Git can automatically resolve it for you.
///////////////////
`git rerere`은 잘 알려지지 않은 기능이다. ``reuse recorded resolution(기록되어있는 해결책 재사용하기)''이 원래 이름이고 이름 그대로 동작한다. Git은 충돌이 났을 때 각 Hunk(역주 - 코드 덩어리)들을 어떻게 처리했는지 기억을 해놨다가 나중에 같은 충돌이라고 생각되어지는 곳에 Git이 자동으로 해결해준다.


///////////////////
There are a number of scenarios in which this functionality might be really handy. One of the examples that is mentioned in the documentation is if you want to make sure a long lived topic branch will merge cleanly but don't want to have a bunch of intermediate merge commits. With `rerere` turned on you can merge occasionally, resolve the conflicts, then back out the merge. If you do this continuously, then the final merge should be easy because `rerere` can just do everything for you automatically.
///////////////////
이 기능을 정말로 능숙하게 사용하게 되면 많은 경우에 활용할 수 있다. 문서에 써있는 예제 중 하나는 긴 토픽 브랜치를 깔끔하게 Merge하고싶은데 임시 Merge커밋을 만들고 싶지 않을 때 사용하는 것이다. Merge할 때에 `rerere` 기능을 켜고, 충돌을 해결한 다음 Merge를 끝낸다. 이 과정을 반복하면 `rerere`가 자동으로 다 해주시니 마지막 Merge는 쉬워진다.

///////////////////
This same tactic can be used if you want to keep a branch rebased so you don't have to deal with the same rebasing conflicts each time you do it.  Or if you want to take a branch that you merged and fixed a bunch of conflicts and then decide to rebase it instead - you likely won't have to do all the same conflicts again.
///////////////////
브랜치를 rebase할 때에도 같은 전략을 사용하면 같은 충돌이 났을 때마다 직접 처리할 필요가 없다. 또는 브랜치 하나를 Merge했을 때 한 무더기 충돌을 처리하고 나서 rebase하기로 마음을 바꿨을 때 같은 충돌 처리를 두번 할 필요 없다.

///////////////////
Another situation is where you merge a bunch of evolving topic branches together into a testable head occasionally, as the Git project itself often does. If the tests fail, you can rewind the merges and re-do them without the topic branch that made the tests fail without having to re-resolve the conflicts again.
///////////////////
또 다른 상황을 생각해보자. 뭔가를 개선한 토픽 브랜치가 여러개 있고 이걸 테스트 브랜치에 한번에 전부 다 Merge하는 일을 종종 해야한다. 테스트가 실패하면 Merge를 취소하고 테스트가 실패한 토픽 브랜치만 빼고나서 다시 Merge를 할 수 있다. 이때 전에 수행했던 충돌을 다시 일일히 손으로 해결하지 않아도 된다.

///////////////////
To enable the `rerere` functionality, you simply have to run this config setting:
///////////////////
`rerere` 기능을 사용하려면 간단히 다음처럼 설정을 변경하면 된다.

[source,console]
----
$ git config --global rerere.enabled true
----

///////////////////
You can also turn it on by creating the `.git/rr-cache` directory in a specific repository, but the config setting is clearer and it can be done globally.
///////////////////
저장소에 `.git/rr-cache` 디렉터리를 만들어서 기능을 켤수도 있다. 이 방법은 설정 파일이 좀 깔끔해지긴 하지만 전역설정이 된다.

///////////////////
Now let's see a simple example, similar to our previous one. Let's say we have a file that looks like this:
///////////////////
이와 비슷한 간단한 예제를 살펴보자. 아래와 같은 파일을 하나 가지고 있다.

[source,console]
----
#! /usr/bin/env ruby

def hello
  puts 'hello world'
end
----

///////////////////
In one branch we change the word ``hello'' to ``hola'', then in another branch we change the ``world'' to ``mundo'', just like before.
///////////////////
이전 예제처럼 한 브랜치에서 ``hello''를 ``hola''로 바꿨다. 그리고 다른 브랜치에서는 ``world''를 ``mundo''로 바꿨다.

image::images/rerere1.png[]

///////////////////
When we merge the two branches together, we'll get a merge conflict:
///////////////////
그리고 이 두 브랜치를 Merge하면 충돌난다.

[source,console]
----
$ git merge i18n-world
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Recorded preimage for 'hello.rb'
Automatic merge failed; fix conflicts and then commit the result.
----

///////////////////
You should notice the new line `Recorded preimage for FILE` in there. Otherwise it should look exactly like a normal merge conflict. At this point, `rerere` can tell us a few things. Normally, you might run `git status` at this point to see what all conflicted:
///////////////////
이 출력 결과에 `Recorded preimage for FILE`라는 줄이 있다는걸 눈여겨봐야한다. 저 말이 없으면 그냥 일반적인 충돌과 다를바없다. 지금은 `rerere`기능 때문에 몇 가지 정보가 더 출력되었다. 보통은 `git status`를 실행해 충돌 정보를 본다.

[source,console]
----
$ git status
# On branch master
# Unmerged paths:
#   (use "git reset HEAD <file>..." to unstage)
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      hello.rb
#
----

///////////////////
However, `git rerere` will also tell you what it has recorded the pre-merge state for with `git rerere status`:
///////////////////
하지만 `git rerere status`명령으로도 기록된 Merge 상태를 볼 수 있다.

[source,console]
----
$ git rerere status
hello.rb
----

///////////////////
And `git rerere diff` will show the current state of the resolution - what you started with to resolve and what you've resolved it to.
///////////////////
그리고 `git rerere diff`로 충돌 해결 후의 현재 상태를 확인한다. todo

[source,console]
----
$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,11 @@
 #! /usr/bin/env ruby

 def hello
-<<<<<<<
-  puts 'hello mundo'
-=======
+<<<<<<< HEAD
   puts 'hola world'
->>>>>>>
+=======
+  puts 'hello mundo'
+>>>>>>> i18n-world
 end
----

///////////////////
Also (and this isn't really related to `rerere`), you can use `ls-files -u` to see the conflicted files and the before, left and right versions:
///////////////////
(`rerere`랑 관련 있는건 아니지만) `ls-files -u`를 이용해서 양쪽 버전의 충돌난 파일들을 볼 수도 있다.

[source,console]
----
$ git ls-files -u
100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1	hello.rb
100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2	hello.rb
100644 54336ba847c3758ab604876419607e9443848474 3	hello.rb
----

///////////////////
Now you can resolve it to just be `puts 'hola mundo'` and you can run the `rerere diff` command again to see what rerere will remember:
///////////////////
이제 `puts 'hola mundo'`를 선택하여 충돌을 해결하자. 그리고 `rerere diff`를 실행하면 rerere는 이를 기억한다.

[source,console]
----
$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-<<<<<<<
-  puts 'hello mundo'
-=======
-  puts 'hola world'
->>>>>>>
+  puts 'hola mundo'
 end
----

///////////////////
So that basically says, when Git sees a hunk conflict in a `hello.rb` file that has ``hello mundo'' on one side and ``hola world'' on the other, it will resolve it to ``hola mundo''.
///////////////////
이제 앞으로 Git이 `hello.rb`의 충돌난 Hunk중에 한 쪽엔 ``hello mundo'', 다른 한 쪽에는 ``hola world''가 있는것을 감지하면 이를 ``hola mundo''로 해결할 것이다.

///////////////////
Now we can mark it as resolved and commit it:
///////////////////
이제 이 파일을 해결한 것으로 표시한 다음에 커밋한다.

[source,console]
----
$ git add hello.rb
$ git commit
Recorded resolution for 'hello.rb'.
[master 68e16e5] Merge branch 'i18n'
----

///////////////////
You can see that it "Recorded resolution for FILE".
///////////////////
여기서 "Recorded resolution for 파일명" 메시지가 보인다.

image::images/rerere2.png[]

///////////////////
Now, let's undo that merge and then rebase it on top of our master branch instead. We can move our branch back by using `reset` as we saw in <<_git_reset>>.
///////////////////
이제 Merge를 되돌리고 Rebase를 해서 master 브랜치위에 우리의 커밋을 붙이자. <<_git_reset>>에서 봤듯이 `reset`을 명령으로 우리의 브랜치로 다시 돌아가자.

[source,console]
----
$ git reset --hard HEAD^
HEAD is now at ad63f15 i18n the hello
----

///////////////////
Our merge is undone. Now let's rebase the topic branch.
///////////////////
Merge가 풀렸다. 이제 토픽 브랜치를 Rebase한다.

[source,console]
----
$ git checkout i18n-world
Switched to branch 'i18n-world'

$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: i18n one word
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Failed to merge in the changes.
Patch failed at 0001 i18n one word
----

///////////////////
Now, we got the same merge conflict like we expected, but take a look at the `Resolved FILE using previous resolution` line. If we look at the file, we'll see that it's already been resolved, there are no merge conflict markers in it.
///////////////////
예상했듯이 Merge했을 때와 같은 충돌이 났다. 하지만 `Resolved 파일명 using previous resolution`라고 쓰인 줄을 보자. 여기에 쓰인 파일을 보면 이미 충돌이 해결된걸 볼 수 있다. Merge 충돌 표시같은건 없다.

[source,console]
----
$ cat hello.rb
#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end
----
 
///////////////////
Also, `git diff` will show you how it was automatically re-resolved:
///////////////////
`git diff`명령어를 실행하면 자동으로 해결된걸 볼 수 있다.

[source,console]
----
$ git diff
diff --cc hello.rb
index a440db6,54336ba..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end
----

image::images/rerere3.png[]

///////////////////
You can also recreate the conflicted file state with the `checkout` command:
///////////////////
`checkout` 명령어로 충돌이난 파일을 다시 불러올 수도 있다.

[source,console]
----
$ git checkout --conflict=merge hello.rb
$ cat hello.rb
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end
----

///////////////////
We saw an example of this in <<_advanced_merging>>.
For now though, let's re-resolve it by just running `rerere` again:
///////////////////
<<_advanced_merging>>에서 이미 이 예제를 봤다.
이번엔 `rerere`를 다시 실행해서 다시 충돌을 해결해보자.

[source,console]
----
$ git rerere
Resolved 'hello.rb' using previous resolution.
$ cat hello.rb
#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end
----

///////////////////
We have re-resolved the file automatically using the `rerere` cached resolution. You can now add and continue the rebase to complete it.
///////////////////
`rerere`가 캐시된 해결방법으로 파일의 충돌을 자동으로 해결했다. 이제 Rebase를 완료하기만 하면 된다.
[source,console]
----
$ git add hello.rb
$ git rebase --continue
Applying: i18n one word
----

///////////////////
So, if you do a lot of re-merges, or want to keep a topic branch up to date with your master branch without a ton of merges, or you rebase often, you can turn on `rerere` to help your life out a bit.
///////////////////
Merge를 다시하는 경우가 많거나 토픽 브랜치의 
