[[_git_stashing]]
=== Stashing과 Cleaning

당신이 어떤 프로젝트에서 한 부분을 담당하고 있다고 하자. 그리고 여기에서 뭔가 작업하던 일이 있고 다른 요청이 들어와서 잠시 브랜치를 변경해야 할 일이 생겼다고 치자. 그런데 이런 상황에서 아직 완료하지 않은 일을 커밋하는 것이 껄끄럽다는 것이 문제다. 커밋하지 않고 나중에 다시 돌아와서 작업을 다시 하고 싶을 것이다. 이 문제는 `git stash`라는 명령으로 해결할 수 있다.

Stash 명령을 사용하면 작업 디렉토리에서 수정한 파일들만 저장한다. Stash는 modified이면서 tracked 상태인 파일과 Staging Area에 있는 파일들을 보관해두는 장소다. 아직 끝내지 않은 수정사항을 스택에 잠시 저장했다가 나중에 다시 적용할 수 있다.

==== 하던 일을 Stash하기

예제 프로젝트를 하나 살펴보자. 파일을 두 개 수정하고 그 중 하나는 Staging Area에 추가한다. 그리고 `git status` 명령을 실행하면 다음과 같은 결과를 볼 수 있다.

[source,console]
----
$ git status
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb
----

이제 브랜치를 변경해 보자. 아직 작업 중인 파일은 커밋할 게 아니라서 모두 Stash한다. `git stash`나 `git stash save`를 실행하면 스택에 새로운 Stash가 만들어진다.

[source,console]
----
$ git stash
Saved working directory and index state \
  "WIP on master: 049d078 added the index file"
HEAD is now at 049d078 added the index file
(To restore them type "git stash apply")
----

대신 작업 디렉토리는 깨끗해졌다.

[source,console]
----
$ git status
# On branch master
nothing to commit, working directory clean
----

이제 아무 브랜치나 골라서 쉽게 바꿀 수 있다. 수정하던 것을 스택에 저장했다. 다음과 같이 `git stash list`를 사용하여 저장한 Stash를 확인한다:

[source,console]
----
$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log
----

Stash 두 개는 원래 있었던 것이다. 그래서 현재 총 세 개의 Stash를 사용할 수 있다. 이제 `git stash apply`를 사용하여 Stash를 적용할 수 있고 이 명령은 `git stash` 명령이 출력하는 도움말에 포함돼 있어서 편리하다. 다른 Stash를 고르고 싶으면 Stash 이름을 입력해야 한다. 이름이 없으면 Git은 가장 최근의 Stash를 적용한다.

[source,console]
----
$ git stash apply
# On branch master
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#
#      modified:   index.html
#      modified:   lib/simplegit.rb
#
----

Git은 Stash에 저장할 때 수정했던 파일들을 복원해준다. 복원할 때의 작업 디렉토리는 Stash할 때의 그 브랜치이고 작업 디렉토리도 깨끗한 상태였다. 하지만, 꼭 깨끗한 Working Directory나 Stash할 때와 같은 브랜치에 적용해야 하는 것은 아니다. 어떤 브랜치에서 Stash하고 다른 브랜치로 옮기고서 거기에 Stash를 복원할 수 있다. 그리고 꼭 작업 디렉토리가 깨끗한 상태일 필요도 없다. 작업 디렉토리에 수정하고 커밋하지 않은 파일들이 있을 때에도 Stash를 적용할 수 있다. 만약 충돌이 있으면 알려준다. 

Git은 Stash를 적용할 때 staged 상태였던 파일을 자동으로 다시 staged 상태로 만들어 주지 않는다. 그래서 `git stash apply` 명령을 실행할 때 `--index` 옵션을 주어 staged 상태까지 적용한다. 그래야 원래 작업하던 상태로 돌아올 수 있다:

[source,console]
----
$ git stash apply --index
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#      modified:   index.html
#
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#
#      modified:   lib/simplegit.rb
#
----

`apply` 옵션은 단순히 Stash를 적용하는 것뿐이다. Stash는 여전히 스택에 남아 있다. `git stash drop` 명령을 사용하여 해당 Stash를 제거한다:

[source,console]
----
$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log
$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)
----

그리고 `git stash pop`이라는 명령도 있는데 이 명령은 Stash를 적용하고 나서 바로 스택에서 제거해준다.

==== Stash를 만드는 새로운 방법

Stash를 만드는 방법은 여러가지가 있다. 꽤나 쓰이는 옵션은 `stash save` 명령어와 같이 쓰이는 `--keep-index`이다. 이 옵션을 이용하면 이미 Staging Area에 들어있는 파일은 stash하지 않는다.

많은 파일을 변경했지만 몇몇 파일만 커밋하고, 커밋 안한 변경 사항들은 나중에 처리하고 싶을때 유용하다.

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb

$ git stash --keep-index
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
M  index.html
----

추적하지 않고 있는 파일과 추적 중인 파일을 같이 stash하는 일도 꽤나 빈번하다. 기본적으로 `git stash`는 추적 중인 파일만 저장한다. 추적중이지 않은 파일을 같이 저장하려면 stash 명령어를 사용할 때 `--include-untracked`나 `-u`옵션을 붙여준다.

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb
?? new-file.txt

$ git stash -u
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
$
----

끝으로, `--patch`플래그를 붙이면 Git은 수정된 모든 사항을 저장하지 않는다. 대신 대화형 프롬프트가 뜨며 변경된 데이터중 저장할 것과 저장하지 않을 것을 지정할 수 있다.

[source,console]
----
$ git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2>&1`.chomp
       end
     end
+
+    def show(treeish = 'master')
+      command("git show #{treeish}")
+    end

 end
 test
Stash this hunk [y,n,q,a,d,/,e,?]? y

Saved working directory and index state WIP on master: 1b65b17 added the index file
----


==== Stash를 적용한 브랜치 만들기

보통 Stash에 저장하면 한동안 그대로 유지하고 그 브랜치에서는 계속 새로운 일을 한다. 그러면 이제 저장한 Stash를 적용하는 것이 문제가 된다. 수정한 파일에 Stash를 적용하면 충돌이 일어날 수도 있고 그러면 또 충돌을 해결해야 한다. 필요한 것은 Stash한 것을 쉽게 다시 테스트하는 것이다. `git stash branch` 명령을 실행하면 Stash할 당시의 커밋을 Checkout 한 후 새로운 브랜치를 만들고 여기에 적용한다. 이 모든 것이 성공하면 Stash를 삭제한다:

[source,console]
----
$ git stash branch testchanges
Switched to a new branch "testchanges"
# On branch testchanges
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#      modified:   index.html
#
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#
#      modified:   lib/simplegit.rb
#
Dropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359)
----

이 명령은 브랜치를 새로 만들고 Stash를 복원해주는 매우 편리한 도구다.

[[_git_clean]]
==== 워킹 디렉터리 청소하기

작업 하고 있던 파일을 stash하지 않고 단순히 그 파일들을 눈 앞에서 치워버리고 싶을 때가 있다. `git clean` 명령어가 그 일을 한다.

보통은 머지나 외부 툴이 만들어낸 파일들을 지우거나 완전히 새로 빌드하기 위해 이전 빌드 작업으로 생성된 각종 파일들을 지우기 위해 이런 일을 한다.


이 명령어를 사용할 때는 신중해야 한다. 이 명령어를 사용하면 워킹 디렉터리 안의 추적하고 있지 않은 모든 파일들이 지워지기 때문이다. 명령어를 실행한 후에는 후회해도 소용없다. 그 파일들은 돌아오지 않는다. `git stash --all`를 이용하면 지우는건 똑같지만 먼저 모든 파일을 stash하므로 좀더 안전하다.

워킹 디렉터리안의 불필요한 파일들을 전부 지우려면 `git clean`을 사용한다. 추적중이지 않은 모든 정보를 워킹 디렉터리에서 지우고싶다면  `git clean -f -d` 명령어를 사용하자. 이 명령어는 하위 디렉터리까지 모두 지워버린다. `-f` 옵션은 강제(_force_)의 의미이며 "진짜로 그냥 해라"라는 뜻이다.


이 명령을 실행했을 때 어떤 일이 일어날지 미리 보고싶다면 `-n`옵션을 사용한다. `-n`옵션은 ``가상으로 실행해보고 어떤 파일들이 지워질지 알려달라''라는 뜻이다.

[source,console]
----
$ git clean -d -n
Would remove test.o
Would remove tmp/
----

`git clean` 명령어는 추적중이지 않은 파일들만 지우는게 기본 동작이다. `.gitignore`에 명시했거나 해서 무시되는 파일들은 지워지지 않는다. 무시된 파일까지 함께 지우려면 `-x` 옵션을 붙인다.

[source,console]
----
$ git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

$ git clean -n -d
Would remove build.TMP
Would remove tmp/

$ git clean -n -d -x
Would remove build.TMP
Would remove test.o
Would remove tmp/
----

`git clean`이 무슨 짓을 할지 확신이 안설때는 항상 `-n` 옵션을 붙여서 먼저 실행하자. clean 명령어를 대화형으로 실행하려면 `-i` 옵션을 붙이면 된다.

[source,console]
----
$ git clean -x -i
Would remove the following items:
  build.TMP  test.o
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit
    6: help
What now>
----

대화형으로 실행하면 파일마다 지우지 말지 결정하거나 특정 패턴으로 걸러서 지울 수도 있다.
