[[_git_submodules]]
=== 서브모듈

프로젝트를 수행하다 보면 다른 프로젝트를 사용해야 하는 경우가 종종 있다. 보통 사용할 프로젝트들은 독립적으로 개발된 라이브러리들이다. 이런 상황에서 자주 생기는 이슈는, 두 프로젝트를 서로 별개로 다루면서도 그 중 하나를 다른 하나 안에서 사용할 수 있어야 한다는 것이다.

Atom 피드를 제공하는 웹사이트를 만든다고 가장하자. Atom 피드를 생성하는 코드는 직접 작성하지 않고 라이브러리를 가져다 쓰기로 했다. 그러면 CPAN이나 Ruby gem 같은 라이브러리 관리 도구를 사용하거나 해당 소스코드를 프로젝트로 복사해야 한다. 사실 라이브러리를 조금 수정하는 것, 설치하기 모두 어렵지만, 사용자들은 모두 이용할 수 있어야 한다. 그래서 프로젝트에 코드를 포함하고 코드를 수정하면 원래 라이브러리 프로젝트의 코드와 Merge하기 어렵게 된다.

Git의 서브모듈은 이런 문제를 해결해준다. 서브모듈은 Git 저장소 안에 다른 Git 저장소를 둘 수 있게 해준다. 이렇게 해도 두 Git 저장소 모두 여전히 독립적으로 관리할 수 있다.

[[_starting_submodules]]
==== 서브모듈 시작하기

///////////
We'll walk through developing a simple project that has been split up into a main project and a few sub-projects.
///////////
메인 프로젝트에 몇가지 작은 프로젝트를 집어넣는 간단한 프로젝트를 직접 진행해볼 것이다.

///////////
Let's start by adding an existing Git repository as a submodule of the repository that we're working on. To add a new submodule you use the `git submodule add` command with the URL of the project you would like to start tracking. In this example, we'll add a library called ``DbConnector''.
///////////
우리가 작업할 Git저장소에 이미 존재하는 Git 저장소를 서브모듈로 추가해보자. 서브모듈을 추가하는 명령어는 `git submodule add`뒤에 추가할 저장소의 URL을 덧붙여주면 된다. 예제에서는 ``DbConnector''라는 라이브러리를 추가한다.

[source,console]
----
$ git submodule add https://github.com/chaconinc/DbConnector
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
----

///////////
By default, submodules will add the subproject into a directory named the same as the repository, in this case ``DbConnector''. You can add a different path at the end of the command if you want it to go elsewhere.
///////////
기본적으로 서브모듈은 하위 프로젝트 저장소의 이름을 가지는 디렉터리를 만든다. 예제에서는 ``DbConnector''라는 이름으로 만들어진다. 명령어의 마지막에 원하는 경로를 넣어 다른 디렉터리 이름으로 서브모듈을 추가 할 수도 있다.

///////////
If you run `git status` at this point, you'll notice a few things.
///////////
이제 `git status`를 실행하면 몇 가지를 알 수 있다.

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   .gitmodules
	new file:   DbConnector
----

`.gitmodules` 파일이 생겼다. 이 것은 로컬 디렉토리와 프로젝트 URL의 매핑 정보가 저장된 설정파일이다:

[source,console]
----
$ cat .gitmodules
[submodule "DbConnector"]
	path = DbConnector
	url = https://github.com/chaconinc/DbConnector
----

서브모듈 개수만큼 이 항목이 있어야 한다. 이 파일도 `.gitignore` 파일처럼 버전이 관리된다. 다른 파일들처럼 Push하고 풀할 수 있다. 이 프로젝트를 Clone하는 사람들은 `.gitmodules` 파일을 참고하여 서브모듈 프로젝트가 어떤 것인지 판단한다.

[NOTE]
=====
///////////
Since the URL in the .gitmodules file is what other people will first try to clone/fetch from, make sure to use a URL that they can access if possible. For example, if you use a different URL to push to than others would to pull from, use the one that others have access to. You can overwrite this value locally with `git config submodule.DbConnector.url PRIVATE_URL` for your own use.
///////////
.gitmodules 파일에 있는 URL을 이용해 다른 사람들이 Clone이나 Fetch를 하기때문에 이 파일에 쓰인 URL은 항상 접근가능한 URL이어야한다. 예를 들어 만약 TODO
=====

`.gitmodules`은 살펴봤고 이제 프로젝트 폴더에 대해 살펴보자. `git diff` 명령을 실행시키면 흥미로운 점을 발견할 수 있다:

[source,console]
----
$ git diff --cached DbConnector
diff --git a/DbConnector b/DbConnector
new file mode 160000
index 0000000..c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc
----

Git은 `DbConnector` 디렉토리를 서브모듈로 취급하기 때문에 파일들을 직접 추적하지 않고 커밋 하나만 저장한다.

///////////
If you want a little nicer diff output, you can pass the `--submodule` option to `git diff`.
///////////
좀 더 나은 출력물을 얻고싶으면 `git diff`명령을 사용할때 `--submodule`옵션을 추가한다.

[source,console]
----
$ git diff --cached --submodule
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "DbConnector"]
+       path = DbConnector
+       url = https://github.com/chaconinc/DbConnector
Submodule DbConnector 0000000...c3f01dc (new submodule)
----

슈퍼프로젝트도 커밋해야 된다.

[source,console]
----
$ git commit -am 'added DbConnector module'
[master fb9093c] added DbConnector module
 2 files changed, 4 insertions(+)
 create mode 100644 .gitmodules
 create mode 160000 DbConnector
----

DbConnector 디렉토리의 모드는 `160000`이다. 160000 모드는 일반적인 파일이나 디렉토리가 아니라 특별하다는 의미다.

[[_cloning_submodules]]
==== 서브모듈이 있는 프로젝트 Clone하기

서브모듈을 사용하는 프로젝트를 Clone하면 해당 서브모듈 디렉토리는 빈 디렉터리다.

[source,console]
----
$ git clone https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
$ cd MainProject
$ ls -la
total 16
drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .
drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..
drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git
-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules
drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector
-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile
drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src
$ cd DbConnector/
$ ls
$
----

분명히 `DbConnector` 디렉토리는 있지만 비워져 있다. 먼저 `git submodule init` 명령으로 서브모듈을 초기화하고 `git submodule update` 명령으로 서버에서 데이터를 가져와야 한다. 데이터를 전부 가져오면 슈퍼프로젝트에 저장된 커밋으로 Checkout된다:

[source,console]
----
$ git submodule init
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
$ git submodule update
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
----

`rack` 디렉토리는 이제 복원했다.

///////////
There is another way to do this which is a little simpler, however. If you pass `--recursive` to the `git clone` command, it will automatically initialize and update each submodule in the repository.
///////////
하지만 더 간단한 방법도 있다. `git clone` 명령뒤에 `--recursive` 옵션을 붙이면 서브모듈을 자동으로 초기화하고 업데이트를 한다.

[source,console]
----
$ git clone --recursive https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
----

///////////
==== Working on a Project with Submodules
///////////
==== 서브모듈이 있는 프로젝트 진행하기

///////////
Now we have a copy of a project with submodules in it and will collaborate with our teammates on both the main project and the submodule project.
///////////
이제 프로젝트에 포함된 서브모듈도 다 받아왔고 메인 프로젝트와 서브 프로젝트를 오가며 팀원들과 협업을 할 것이다.

///////////
===== Pulling in Upstream Changes
///////////
===== 업스트림의 변경점 가져오기

///////////
The simplest model of using submodules in a project would be if you were simply consuming a subproject and wanted to get updates from it from time to time but were not actually modifying anything in your checkout. Let's walk though a simple example there.
///////////
단순히 서브 프로젝트를 가져다쓰고 그때그때 업데이트 분을 가져와서 적용하지만 서브 프로젝트자체를 직접 수정하지는 않는것이 서브모듈을 사용하는 가장 단순한 모델이다. 간단한 예제로 이렇게 사용해보자.

///////////
If you want to check for new work in a submodule, you can go into the directory and run `git fetch` and `git merge` the upstream branch to update the local code.
///////////
서브모듈을 업데이트하려면 그 디렉터리로 가서 `git fetch`를 실행하고 그 다음 `git merge`를 실행한다.

[source,console]
----
$ git fetch
From https://github.com/chaconinc/DbConnector
   c3f01dc..d0354fc  master     -> origin/master
Scotts-MacBook-Pro-3:DbConnector schacon$ git merge origin/master
Updating c3f01dc..d0354fc
Fast-forward
 scripts/connect.sh | 1 +
 src/db.c           | 1 +
 2 files changed, 2 insertions(+)
----

///////////
Now if you go back into the main project and run `git diff --submodule` you can see that the submodule was updated and get a list of commits that were added to it. If you don't want to type `--submodule` every time you run `git diff`, you can set it as the default format by setting the `diff.submodule` config value to ``log''.
///////////
메인 프로젝트로 돌아와서 `git diff --submodule`을 실행하면 업데이트된 서브모듈과 각 서브모듈에 추가된 커밋들을 볼 수 있다. 매번 `--submodule`옵션을 쓰고싶지 않다면 `diff.submodule`의 값을 ``log''로 설정하면 된다.

[source,console]
----
$ git config --global diff.submodule log
$ git diff
Submodule DbConnector c3f01dc..d0354fc:
  > more efficient db routine
  > better connection routine
----

///////////
If you commit at this point then you will lock the submodule into having the new code when other people update.
///////////
이 시점에서 커밋을 하면 서브 모듈은 다른 사람이 업데이트 한 새로운 코드로 고정된다.

///////////
There is an easier way to do this as well, if you prefer to not manually fetch and merge in the subdirectory. If you run `git submodule update --remote`, Git will go into your submodules and fetch and update for you.
///////////
더 쉬운 방법도 있다. 일일히 손으로 서브모듈을 Fatch나 Merge하기 싫다면 `git submodule update --remote`를 실행한다. 그러면 Git은 자동으로 서브모듈로 들어가서 Fetch후에 Update를 한다.

[source,console]
----
$ git submodule update --remote DbConnector
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   3f19983..d0354fc  master     -> origin/master
Submodule path 'DbConnector': checked out 'd0354fc054692d3906c85c3af05ddce39a1c0644'
----

///////////
This command will by default assume that you want to update the checkout to the `master` branch of the submodule repository. You can, however, set this to something different if you want. For example, if you want to have the DbConnector submodule track that repository's ``stable'' branch, you can set it in either your `.gitmodules` file (so everyone else also tracks it), or just in your local `.git/config` file.  Let's set it in the `.gitmodules` file:
///////////
이 명령어는 각 서브모듈 저장소의 `master` 브랜치를 Checkout하고 업데이트를 수행한다. 하지만 원한다면 좀 바꿀수도 있다. 예를 들어서 당신이 추적하고 있는 DbConnector 서브모듈 저장소의 브랜치를 ``stable''로 바꾸고 싶다면 `.gitmodules`파일을 바꾸거나(그러면 이 파일을 공유하는 모두가 ``stable''을 추적하게된다) 개인 설정 파일인 `.git/config`파일을 변경한다. `.gitmodules`파일에 세팅하는 방법을 알아보자.

[source,console]
----
$ git config -f .gitmodules submodule.DbConnector.branch stable

$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   27cf5d3..c87d55d  stable -> origin/stable
Submodule path 'DbConnector': checked out 'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'
----

///////////
If you leave off the `-f .gitmodules` it will only make the change for you, but it probably makes more sense to track that information with the repository so everyone else does as well.
///////////
`-f .gitmodules`를 포함하지 않으면 이 변경은 당신에게만 적용된다. 하지만 다른 모든 사람도 공유하고 있는 저장소라면 같은 브랜치를 추적하도록 하는것이 더 낫다.

///////////
When we run `git status` at this point, Git will show us that we have ``new commits'' on the submodule.
///////////
이제 `git status`를 실행하면 서브모듈에 ``new commits''가 있다는걸 알 수 있다.

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

  modified:   .gitmodules
  modified:   DbConnector (new commits)

no changes added to commit (use "git add" and/or "git commit -a")
----

///////////
If you set the configuration setting `status.submodulesummary`, Git will also show you a short summary of changes to your submodules:
///////////
`status.submodulesummary`플래그를 켜면 서브모듈의 변경 사항을 간단히 보여주기도한다.

[source,console]
----
$ git config status.submodulesummary 1

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   .gitmodules
	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c3f01dc...c87d55d (4):
  > catch non-null terminated lines
----

///////////
At this point if you run `git diff` we can see both that we have modified our `.gitmodules` file and also that there are a number of commits that we've pulled down and are ready to commit to our submodule project.
///////////
그리고 `git diff`을 실행하자. 그러면 `.gitmodules`이 변경된 것과 우리가 서브모듈 저장소에서 가져와서 이제 커밋해줘야 할 변경 사항들이 보인다. TODO

[source,console]
----
$ git diff
diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
 Submodule DbConnector c3f01dc..c87d55d:
  > catch non-null terminated lines
  > more robust error handling
  > more efficient db routine
  > better connection routine
----

///////////
This is pretty cool as we can actually see the log of commits that we're about to commit to in our submodule. Once committed, you can see this information after the fact as well when you run `git log -p`.
///////////
서브모듈에 실제로 커밋할 커밋들의 정보를 보기에는 꽤 괜찮은 방법이다. 커밋을 한 후에는 `git log -p`로 이 정보들을 볼 수 있다. 


[source,console]
----
$ git log -p --submodule
commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Sep 17 16:37:02 2014 +0200

    updating DbConnector for bug fixes

diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
Submodule DbConnector c3f01dc..c87d55d:
  > catch non-null terminated lines
  > more robust error handling
  > more efficient db routine
  > better connection routine
----

///////////
Git will by default try to update **all** of your submodules when you run `git submodule update --remote` so if you have a lot of them, you may want to pass the name of just the submodule you want to try to update.
///////////
`git submodule update --remote`를 실행하면 기본적으로 **모든** 서브모듈을 업데이트한다. 그래서 서브모듈이 엄청 많을 경우엔 업데이트할 서브모듈의 이름을 지정할 수도 있다.

///////////
===== Working on a Submodule
///////////
===== 서브모듈에서 작업하기

///////////
It's quite likely that if you're using submodules, you're doing so because you really want to work on the code in the submodule at the same time as you're working on the code in the main project (or across several submodules). Otherwise you would probably instead be using a simpler dependency managment system (such as Maven or Rubygems).
///////////
서브모듈을 사용하다가 서브모둘에서 뭔가를 작업을 해야할 일은 얼마든지 생길 수 있다. 거기에 더해 메인 프로젝트에서 작업하는 도중에 말이다.(동시에 다른 서브모듈을 건드려야하거나) 그렇지 않으면 간단한 (Maven이나 Rubygem같은)의존성 관리 시스템을 사용할 수도 있다. TODO

///////////
So now let's go through an example of making changes to the submodule at the same time as the main project and committing and publishing those changes at the same time.
///////////
메인 프로젝트와 서브모듈을 동시에 수정해서 커밋하고 공유하는 것 까지 따라가보자.

///////////
So far, when we've run the `git submodule update` command to fetch changes from the submodule repositories, Git would get the changes and update the files in the subdirectory but will leave the sub-repository in what's called a ``detached HEAD'' state. This means that there is no local working branch (like ``master'', for example) tracking changes. So any changes you make aren't being tracked well.
///////////
서브모듈 저장소에서 변경 사항을 가져오려고 `git submodule update`를 실행하면 Git이 서브모듈의 변경 사항을 업데이트한다. 하지만 서브모듈 로컬 저장소는 ``detached HEAD''상태로 남아있다. 이 말인 즉슨, 변경점을 추적하는 로컬 브랜치(예를 들자면 ``master''같은)가 없다는 것이다. 그래서 당신이 서브모듈을 수정해도 추적되지 않는다.

///////////
In order to set up your submodule to be easier to go in and hack on, you need do two things. You need to go into each submodule and check out a branch to work on. Then you need to tell Git what to do if you have made changes and then `git submodule update --remote` pulls in new work from upstream. The options are that you can merge them into your local work, or you can try to rebase your local work on top of the new changes.
///////////
서브모듈의 브랜치를 추적하는 것처럼 하려면 할 일이 두 가지가 있다. 우선 각 서므모듈 디렉터리로 가서 브랜치를 Checkout하고 일을 시작해야 한다. 그리고 모듈을 수정한다음에 `git submodule update --remote`를 실행해 upstream에서 새로운 커밋을 가져온다. 이 커밋을 Merge하거나 Rebase하는 것은 당신의 선택이다.

///////////
First of all, let's go into our submodule directory and check out a branch.
///////////
먼저 서브모듈 디렉터리로 가서 브랜치를 체크아웃하자.

[source,console]
----
$ git checkout stable
Switched to branch 'stable'
----

///////////
Let's try it with the ``merge'' option. To specify it manually, we can just add the `--merge` option to our `update` call. Here we'll see that there was a change on the server for this submodule and it gets merged in.
///////////
선택사항중 하나인 ``Merge''를 하자. `update`명령어를 쓸때 `--merge` 옵션을 추가하면된다. 아래 출력에서 서버로 부터 서브모듈의 변경점을 가져와서 Merge하는 과정을 볼 수 있다.

[source,console]
----
$ git submodule update --remote --merge
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   c87d55d..92c7337  stable     -> origin/stable
Updating c87d55d..92c7337
Fast-forward
 src/main.c | 1 +
 1 file changed, 1 insertion(+)
Submodule path 'DbConnector': merged in '92c7337b30ef9e0893e758dac2459d07362ab5ea'
----

///////////
If we go into the DbConnector directory, we have the new changes already merged into our local `stable` branch. Now let's see what happens when we make our own local change to the library and someone else pushes another change upstream at the same time.
///////////
DbConnector 디렉터리로 들어가면 새 변경점이 로컬 브랜치 `stable`에 이미 Merge된걸 확인할 수 있다. 이제 우리가 라이브러리를 수정하고 동시에 다른 사람도 같은 것을 수정하여 푸시를 했을 때 무슨 일이 일어나는지 보자.

[source,console]
----
$ cd DbConnector/
$ vim src/db.c
$ git commit -am 'unicode support'
[stable f906e16] unicode support
 1 file changed, 1 insertion(+)
----

///////////
Now if we update our submodule we can see what happens when we have made a local change and upstream also has a change we need to incorporate.
///////////
우리의 서브모듈을 업데이트하면 로컬의 변경점에 어떤 일이 일어났는지 볼 수 있고, 통합해야할 작업이 upstream에 생긴 것도 알 수 있다.

[source,console]
----
$ git submodule update --remote --rebase
First, rewinding head to replay your work on top of it...
Applying: unicode support
Submodule path 'DbConnector': rebased into '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
----

///////////
If you forget the `--rebase` or `--merge`, Git will just update the submodule to whatever is on the server and reset your project to a detached HEAD state.
///////////
`--rebase`옵션이나 `--merge`옵션을 빼먹으면 Git은 서버에 어떤 내용이 있는지 상관않고 서브모듈을 업데이트 한 다음 detached HEAD상태로 만든다.

[source,console]
----
$ git submodule update --remote
Submodule path 'DbConnector': checked out '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
----

///////////
If this happens, don't worry, you can simply go back into the directory and check out your branch again (which will still contain your work) and merge or rebase `origin/stable` (or whatever remote branch you want) manually.
///////////
그래도 걱정할 필요없다. 문제가 발생한 디렉터리로 가서 다시 브랜치를 Checkout하고 직접 손으로 `origin/stable`(아니면 원하는 어떠한 리모트 브랜치든)을 Merge하거나 Rebase하면 된다.

///////////
If you haven't committed your changes in your submodule and you run a submodule update that would cause issues, Git will fetch the changes but not overwrite unsaved work in your submodule directory.
///////////
서브모듈에 커밋하지 않은 변경 사항이 있는 채로 서브모듈을 업데이트했는데 이런 문제가 생겼으면 Git은 변경 사항을 가져오지만 서브모듈의 저장하지않은 작업을 덮어쓰지 않는다.

[source,console]
----
$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 4 (delta 0)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   5d60ef9..c75e92a  stable     -> origin/stable
error: Your local changes to the following files would be overwritten by checkout:
	scripts/setup.sh
Please, commit your changes or stash them before you can switch branches.
Aborting
Unable to checkout 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'
----

///////////
If you made changes that conflict with something changed upstream, Git will let you know when you run the update.
///////////
서버에서 받아온 번경 사항과 충돌이 나면 업데이트 명령어를 실행했을 때 알려준다. 

[source,console]
----
$ git submodule update --remote --merge
Auto-merging scripts/setup.sh
CONFLICT (content): Merge conflict in scripts/setup.sh
Recorded preimage for 'scripts/setup.sh'
Automatic merge failed; fix conflicts and then commit the result.
Unable to merge 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'
----

///////////
You can go into the submodule directory and fix the conflict just as you normally would.
///////////
그럴땐 서브모듈 디렉터리로 가서 충돌을 해결하면 된다.

[[_publishing_submodules]]
///////////
===== Publishing Submodule Changes
///////////
===== 서브모듈 변경점 공유하기

///////////
Now we have some changes in our submodule directory. Some of these were brought in from upstream by our updates and others were made locally and aren't available to anyone else yet as we haven't pushed them yet.
///////////
이제 서브모듈이 변경되었다. 이 중 일부는 업데이트하여 서버에서 가져온 것이고, 나머지는 로컬에서 수정했다. 로컬에서 수정한 것은 아직 공유하지 않았으므로 아무도 사용할 수 없는 코드이다.

[source,console]
----
$ git diff
Submodule DbConnector c87d55d..82d2ad3:
  > Merge from origin/stable
  > updated setup script
  > unicode support
  > remove unnessesary method
  > add new option for conn pooling
----

///////////
If we commit in the main project and push it up without pushing the submodule changes up as well, other people who try to check out our changes are going to be in trouble since they will have no way to get the submodule changes that are depended on. Those changes will only exist on our local copy.
///////////
서브모듈의 변경사항을 Push하지 않은 채로 메인 프로젝트에서의 커밋을 Push하면 우리의 변경 사항을 Checkout한 다른 사람은 서브모듈에 의존성이 있는 메인 코드만을 받았으므로 곤란해진다. 서브모듈의 변경사항은 우리의 로컬에만 있기때문이다.

///////////
In order to make sure this doesn't happen, you can ask Git to check that all your submodules have been pushed properly before pushing the main project. The `git push` command takes the `--recurse-submodules` argument which can be set to either ``check'' or ``on-demand''. The ``check'' option will make `push` simply fail if any of the committed submodule changes haven't been pushed.
///////////
이런 불상사가 발생하지 않도록 하려면 메인 프로젝트를 Push하기전에 서브모듈을 모두 Push했는지 검사하도록 Git에게 물어보면된다. `git push`명령어에 `--recurse-submodules`옵션을 주고 이 옵션의 값으로 ``check''나 ``on-demand''를 설정한다. ``check''는 간단히 서브모듈의 로컬 커밋이 Push되지 않은 상태라면 현재의 `Push`명령도 실패하는 옵션이다.

[source,console]
----
$ git push --recurse-submodules=check
The following submodule paths contain changes that can
not be found on any remote:
  DbConnector

Please try

	git push --recurse-submodules=on-demand

or cd to the path and use

	git push

to push them to a remote.
----

///////////
As you can see, it also gives us some helpful advice on what we might want to do next. The simple option is to go into each submodule and manually push to the remotes to make sure they're externally available and then try this push again.
///////////
예제에서 볼 수있듯이 우리가 다음에 무엇을 해야하는지 알 수 있다. 각 서브모듈 디렉터리로 가서 직접 일일히 Push를 해서 외부와 공유를 한 후에 메인 프로젝트를 푸시한다.

///////////
The other option is to use the ``on-demand'' value, which will try to do this for you.
///////////
다른 옵션으로는 ``on-demand''를 쓴다. 이 옵션은 필요할 때 시도한다.

[source,console]
----
$ git push --recurse-submodules=on-demand
Pushing submodule 'DbConnector'
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 3), reused 0 (delta 0)
To https://github.com/chaconinc/DbConnector
   c75e92a..82d2ad3  stable -> stable
Counting objects: 2, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To https://github.com/chaconinc/MainProject
   3d6d338..9a377d1  master -> master
----

///////////
As you can see there, Git went into the DbConnector module and pushed it before pushing the main project. If that submodule push fails for some reason, the main project push will also fail.
///////////
위에서 보듯이 Git이 메인 프로젝트를 Push하기 전에 DbConnector 모듈로 들어가서 Push를 한다. 모종의 이유로 인해 서브모듈 Push를 실패하면 메인 프로젝트의 Push또한 실패한다.

///////////
===== Merging Submodule Changes
///////////
===== 서브모듈 변경사항 Merge하기

///////////
If you change a submodule reference at the same time as someone else, you may run into some problems. That is, if the submodule histories have diverged and are committed to diverging branches in a superproject, it may take a bit of work for you to fix.
///////////
다른 누군가와 동시에 서브모듈을 수정하면 몇 가지 문제에 봉착하게된다. 즉, 서브모듈의 히스토리가 갈라져서 상위 프로젝트에 무언가가 커밋되었으면 사태를 바로잡기 위해 해야할 일이 생긴다.

///////////
If one of the commits is a direct ancestor of the other (a fast-forward merge), then Git will simply choose the latter for the merge, so that works fine.
///////////
커밋들중 하나가 다른 커밋의 직접적인 조상이면(Fast-Forward Merge), Git은 간단히 마지막 Merge를 선택한다.

///////////
git will not attempt even a trivial merge for you, however. If the submodule commits diverge and need to be merged, you will get something that looks like this:
///////////
하지만 Git은 사소한 Merge조차하지 않는다. 서브모듈 커밋들이 분기되었다가 Merge를 해야할 때, 아래와 같은 것을 보게 된다.

[source,console]
----
$ git pull
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 2 (delta 1), reused 2 (delta 1)
Unpacking objects: 100% (2/2), done.
From https://github.com/chaconinc/MainProject
   9a377d1..eb974f8  master     -> origin/master
Fetching submodule DbConnector
warning: Failed to merge submodule DbConnector (merge following commits not found)
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.
----

///////////
So basically what has happened here is that Git has figured out that the two branches record points in the submodule's history that are divergent and need to be merged. It explains it as ``merge following commits not found'', which is confusing but we'll explain why that is in a bit.
///////////
그래서 기본적으로 여기서 알수 있는 것은 Git이 서브모듈에서 두 브랜치의 Merge해야 할 지점을 알고있다는 것이다. 이 일은 ``merge following commits not found''라고 설명하고 있는데, 이는 혼란 스럽지만 왜 그런지 설명할 수 있다.

///////////
To solve the problem, you need to figure out what state the submodule should be in. Strangely, Git doesn't really give you much information to help out here, not even the SHAs of the commits of both sides of the history. Fortunately, it's simple to figure out.  If you run `git diff` you can get the SHAs of the commits recorded in both branches you were trying to merge.
///////////
이 문제를 해결하기 위해서, 서브모듈이 어떤 상태여야 하는지 알고 있어야한다. 이상하게도 Git은 더 많은 정보를 주지 않는다. 양쪽 히스토리에 있는 커밋의 SHA도 알려주지 않는다. 그래도 알아내는 건 간단하다. `git diff`를 실행하면 Merge하려는 양쪽 브랜치에 담겨진 커밋의 SHA를 알 수 있다.

[source,console]
----
$ git diff
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
----

///////////
So, in this case, `eb41d76` is the commit in our submodule that *we* had and `c771610` is the commit that upstream had. If we go into our submodule directory, it should already be on `eb41d76` as the merge would not have touched it. If for whatever reason it's not, you can simply create and checkout a branch pointing to it.
///////////
여기서는 `eb41d76`이 *우리*가 가진 서브모듈의 커밋이고 `c771610`이 Upstream에 있는 커밋이다. 서브모듈의 디렉터리로 가면 이미 `eb41d76`가 손대지 않은 채로 있어야한다.TODO

///////////
What is important is the SHA of the commit from the other side. This is what you'll have to merge in and resolve. You can either just try the merge with the SHA directly, or you can create a branch for it and then try to merge that in. We would suggest the latter, even if only to make a nicer merge commit message.
///////////
중요한건 다른 쪽 커밋의 SHA이다. 이쪽이 Merge해야할 대상이다. SHA를 명시하여 곧바로 Merge할 수도 있고, 여기서 브랜치를 하나 만들어 Merge를 할 수도 있다. 더 멋진 Merge 커밋 메시지를 위해서라도 후자를 추천한다.

///////////
So, we will go into our submodule directory, create a branch based on that second SHA from `git diff` and manually merge.
///////////
그러면 이제 서브모듈 디렉터리로 들거가서 `git diff`에서 나온 두 번째 SHA에 브랜치를 만들고 수동으로 Merge하자.

[source,console]
----
$ cd DbConnector

$ git rev-parse HEAD
eb41d764bccf88be77aced643c13a7fa86714135

$ git branch try-merge c771610
(DbConnector) $ git merge try-merge
Auto-merging src/main.c
CONFLICT (content): Merge conflict in src/main.c
Recorded preimage for 'src/main.c'
Automatic merge failed; fix conflicts and then commit the result.
----

///////////
We got an actual merge conflict here, so if we resolve that and commit it, then we can simply update the main project with the result.
///////////
실제 Merge시 충돌이 일어났고, 해결한 다음 커밋했다. 그리고 이 결과로 메인 프로젝트를 업데이트한다.

[source,console]
----
$ vim src/main.c <1>
$ git add src/main.c
$ git commit -am 'merged our changes'
Recorded resolution for 'src/main.c'.
[master 9fd905e] merged our changes

$ cd .. <2>
$ git diff <3>
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
@@@ -1,1 -1,1 +1,1 @@@
- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135
 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d
++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a
$ git add DbConnector <4>

$ git commit -m "Merge Tom's Changes" <5>
[master 10d2c60] Merge Tom's Changes
----

///////////
<1> First we resolve the conflict
<2> Then we go back to the main project directory
<3> We can check the SHAs again
<4> Resolve the conflicted submodule entry
<5> Commit our merge
///////////
<1> 먼저 충돌을 해결했다
<2> 그리고 메인 프로젝트로 돌아간다.
<3> SHA를 다시 검사하고
<4> 충돌난 서브모듈을 해결한다.
<5> Merge 결과를 커밋한다.

///////////
It can be a bit confusing, but it's really not very hard.
///////////
좀 따라가기 힘들수 있지만 사실 그렇게 어려운건 아니다.

///////////
Interestingly, there is another case that Git handles.
If a merge commit exists in the submodule directory that contains **both** commits in it's history, Git will suggest it to you as a possible solution. It sees that at some point in the submodule project, someone merged branches containing these two commits, so maybe you'll want that one.
///////////
Git으로 이 문제를 해결하는 방법이 또 있다. 재미있지않은가.
Merge커밋이 서브모듈 디렉터리에 존재하면, Git은 실행 가능한 해결책을 내놓는다. 이 해결책은 서브모듈의 어떤 부분을 보면 누군가가 두 커밋이 포함된 브랜치를 머지해 둔것이 있다. 이를 취하면 된다.

///////////
This is why the error message from before was ``merge following commits not found'', because it could not do *this*. It's confusing because who would expect it to **try** to do this?
///////////
이 방벅이 *이걸*하지 않기 때문에 위에서 ``merge following commits not found''라는 메시지가 나온 것이다. 누가 이걸 *시도*할까 싶으니 혼란스러울 것이다.

///////////
If it does find a single acceptable merge commit, you'll see something like this:
///////////
만약 접근 가능한 하나의 머지커밋이 있다면 아래와 같은 결과를 볼 수있다.

[source,console]
----
$ git merge origin/master
warning: Failed to merge submodule DbConnector (not fast-forward)
Found a possible merge resolution for the submodule:
 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: > merged our changes
If this is correct simply add it to the index for example
by using:

  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a "DbConnector"

which will accept this suggestion.
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.
----

What it's suggesting that you do is to update the index like you had run `git add`, which clears the conflict, then commit. You probably shouldn't do this though. You can just as easily go into the submodule directory, see what the difference is, fast-forward to this commit, test it properly, and then commit it.

[source,console]
----
$ cd DbConnector/
$ git merge 9fd905e
Updating eb41d76..9fd905e
Fast-forward

$ cd ..
$ git add DbConnector
$ git commit -am 'Fast forwarded to a common submodule child'
----

This accomplishes the same thing, but at least this way you can verify that it works and you have the code in your submodule directory when you're done.


==== Submodule Tips

There are a few things you can do to make working with submodules a little easier.

===== Submodule Foreach

There is a `foreach` submodule command to run some arbitrary command in each submodule. This can be really helpful if you have a number of submodules in the same project.

For example, let's say we want to start a new feature or do a bugfix and we have work going on in several submodules. We can easily stash all the work in all our submodules.

[source,console]
----
$ git submodule foreach 'git stash'
Entering 'CryptoLibrary'
No local changes to save
Entering 'DbConnector'
Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable
HEAD is now at 82d2ad3 Merge from origin/stable
----

Then we can create a new branch and switch to it in all our submodules.

[source,console]
----
$ git submodule foreach 'git checkout -b featureA'
Entering 'CryptoLibrary'
Switched to a new branch 'featureA'
Entering 'DbConnector'
Switched to a new branch 'featureA'
----

You get the idea. One really useful thing you can do is produce a nice unified diff of what is changed in your main project and all your subprojects as well.

[source,console]
----
$ git diff; git submodule foreach 'git diff'
Submodule DbConnector contains modified content
diff --git a/src/main.c b/src/main.c
index 210f1ae..1f0acdc 100644
--- a/src/main.c
+++ b/src/main.c
@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)

      commit_pager_choice();

+     url = url_decode(url_orig);
+
      /* build alias_argv */
      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));
      alias_argv[0] = alias_string + 1;
Entering 'DbConnector'
diff --git a/src/db.c b/src/db.c
index 1aaefb6..5297645 100644
--- a/src/db.c
+++ b/src/db.c
@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)
        return url_decode_internal(&url, len, NULL, &out, 0);
 }

+char *url_decode(const char *url)
+{
+       return url_decode_mem(url, strlen(url));
+}
+
 char *url_decode_parameter_name(const char **query)
 {
        struct strbuf out = STRBUF_INIT;
----

Here we can see that we're defining a function in a submodule and calling it in the main project. This is obviously a simplified example, but hopefully it gives you an idea of how this may be useful.

===== Useful Aliases

You may want to set up some aliases for some of these commands as they can be quite long and you can't set configuration options for most of them to make them defaults. We covered setting up Git aliases in [[_git_aliases]], but here is an example of what you may want to set up if you plan on working with submodules in Git a lot.

[source,console]
----
$ git config alias.sdiff '!'"git diff && git submodule foreach 'git diff'"
$ git config alias.spush 'push --recurse-submodules=on-demand'
$ git config alias.supdate 'submodule update --remote --merge'
----

This way you can simply run `git supdate` when you want to update your submodules, or `git spush` to push with submodule dependency checking.

==== 서브모듈 사용할 때 주의할 점들

전체적으로 서브모듈은 어렵지 않게 사용할 수 있지만, 서브모듈의 코드를 수정하는 경우에는 주의할 필요가 있다.

For instance switching branches with submodules in them can also be tricky.
If you create a new branch, add a submodule there, and then switch back to a branch without that submodule, you still have the submodule directory as an untracked directory:

[source,console]
----
$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'adding crypto library'
[add-crypto 4445836] adding crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	CryptoLibrary/

nothing added to commit but untracked files present (use "git add" to track)
----

Removing the directory isn't difficult, but it can be a bit confusing to have that in there. If you do remove it and then switch back to the branch that has that submodule, you will need to run `submodule update --init` to repopulate it.

[source,console]
----
$ git clean -ffdx
Removing CryptoLibrary/

$ git checkout add-crypto
Switched to branch 'add-crypto'

$ ls CryptoLibrary/

$ git submodule update --init
Submodule path 'CryptoLibrary': checked out 'b8dda6aa182ea4464f3f3264b11e0268545172af'

$ ls CryptoLibrary/
Makefile	includes	scripts		src
----

Again, not really very difficult, but it can be a little confusing.

The other main caveat that many people run into involves switching from subdirectories to submodules.
If you’ve been tracking files in your project and you want to move them out into a submodule, you must be careful or Git will get angry at you.
Assume that you have files in a subdirectory of your project, and you want to switch it to a submodule.
If you delete the subdirectory and then run `submodule add`, Git yells at you:

[source,console]
----
$ rm -Rf CryptoLibrary/
$ git submodule add https://github.com/chaconinc/CryptoLibrary
'CryptoLibrary' already exists in the index
----

You have to unstage the `CryptoLibrary` directory first.
Then you can add the submodule:

[source,console]
----
$ git rm -r CryptoLibrary
$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
----

Now suppose you did that in a branch.
If you try to switch back to a branch where those files are still in the actual tree rather than a submodule – you get this error:

[source,console]
----
$ git checkout master
error: The following untracked working tree files would be overwritten by checkout:
  CryptoLibrary/Makefile
  CryptoLibrary/includes/crypto.h
  ...
Please move or remove them before you can switch branches.
Aborting
----

You can force it to switch with `checkout -f`, but be careful that you don't have unsaved changes in there as they could be overwritten with that command.

[source,console]
----
$ git checkout -f master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
----

Then, when you switch back, you get an empty `CryptoLibrary` directory for some reason and `git submodule update` may not fix it either. You may need to go into your submodule directory and run a `git checkout .` to get all your files back. You could run this in a `submodule foreach` script to run it for multiple submodules.

It's important to note that submodules these days keep all their Git data in the top project's `.git` directory, so unlike much older versions of Git, destorying a submodule directory won't lose any commits or branches that you had.

With these tools, submodules can be a fairly simple and effective method for developing on several related but still separate projects simultaneously.
